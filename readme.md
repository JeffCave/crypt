# Enigma

In my second to last semester of my Bachelors, we had an assignment to write an encryption algorithm. I had just finished reading <a href='https://www.amazon.ca/gp/product/0385495323/ref=as_li_tf_tl?ie=UTF8&camp=15121&creative=330641&creativeASIN=0385495323&linkCode=as2&tag=vius-20'>The Code Book</a>, and knowing how difficult a problem this is, and knowing how weak most homebrewed encryption algorithms are, I proposed implementing a digital form of the Enigma machine, the prof accepted.

Technically this is *not* an Enigma, but rather a rotor-cipher machine (or possibly a stepping switch); specifically this algorithm does not implement features specified in the Enigma patents, and are normally found in implementation examples (in particular the plug board, and reflector). 

According to the timestamps on some of the files, it appears this was written late 1999, maybe early 2001.

More on the Rotor-Cipher machines: https://en.wikipedia.org/wiki/Enigma_machine

Classic example of the same problem: https://en.wikipedia.org/wiki/Crypt_(Unix)

## Implmentation

Early examples of Rotor-Cipher machines include 1 to 3 wheels, each containing ~20 characters. The key element here is that the more wheels you add, the more difficult it is to break; and the larger the wheel, the more characters you can use to compose your message.

In an effort to handle any type of input I used a 256-byte alphabet, allowing the system to effectively encrypt any 8-bit content. Further, during The Second World War, mechanical brute force techniques were developed that were moderately successful at breaking these ciphers. We have a lot more computing power now. To overcome this I allowed for a fixed wheel count of 256 wheels (I seem to remember reducing this to 127 wheels in an effort to speed things up).

Encryption keys are a shared secret file that can be autogenerated by the program. It contains a copy of the wheels to be used, their starting position, and order. I think the intent was to make it so that a Wheel Sets could be distributed among a group, while individuals shared secrets about the position and order.

Put all of this together, and (according to <a href='https://en.wikipedia.org/wiki/Enigma_machine#Mathematical_analysis'>Wikipedia</a>) you get

    E : Encryption complexity
    R : Rotor transform
    n : number of rotors used

    E = R^n

The value associate with the rotor (R) is determined by the complexity of the individual rotors, as well as being impacted by the number of times it is incremented

    R = ...

You know what, this was a class assignment 15 years ago: `E` evaluates to a really big number. This is not to say this is strong encryption; rather, this relies on a mechanism that was first broken in the early 1900s, and was completely obsolete by the 1970s.

In the spirit of `crypt`: its a fun toy... go forth and play. I especially would love for someone to demonstrate a nice mechanism for breaking the encryption.


## Executable notes

I know this was originally developed using the Borland CPP compiler (unclear on which version). It is for windows only, and has a requirement for `CW3230.DLL`. 

Given I no longer have the original compiler, work on Linux, and probably don't have license to distribute one of the dependancies I have included the EXE that was sitting on the floppy disk I found this on.
